import express from "express";
import cors from "cors";
import dotenv from "dotenv";
import { GoogleGenerativeAI } from "@google/generative-ai";

dotenv.config();

const app = express();
app.use(cors({
  origin: [
    'http://localhost:5173', // local dev
    'https://codemate-kappa.vercel.app' // deployed frontend    process.env.FRONTEND_URL // production frontend

  ],
  credentials: true
}));
app.use(express.json());

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// ✅ API route for code review
app.post("/api/review", async (req, res) => {
  try {
    const { code, language } = req.body;

    // Validate input
    if (!code || !language) {
      return res.status(400).json({ error: "Code and language are required." });
    }

    const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });

    const prompt = `
You are an expert software developer.
Analyze the following ${language} code carefully and provide structured feedback:
Start with the line "As your codemate, ..."

==============================
${code}
==============================

Please include:
1️⃣ Code quality rating — Better / Good / Normal / Bad.
2️⃣ Suggested improvements and best practices.
3️⃣ Step-by-step explanation of what the code does.
4️⃣ Potential bugs or logical issues.
5️⃣ Any syntax or runtime errors. And if there is any error write it in red color.
6️⃣ Recommendations for fixes or optimizations.
`;

    const result = await model.generateContent(prompt);

    // ✅ Safely extract text output
    const text = result.response?.text?.() || "No response generated by the AI.";
    res.json({ analysis: text });
  } catch (err) {
    console.error("❌ Error in /api/review:", err);
    res.status(500).json({ error: "Internal Server Error", details: err.message });
  }
});
app.post("/api/visualize", async (req, res) => {
  try {
    const { code, language } = req.body;

    // Validate input
    if (!code || !language) {
      return res.status(400).json({ error: "Code and language are required." });
    }

    const model = genAI.getGenerativeModel({ model: "gemini-2.5-pro" });

const prompt = `
You are an expert data structure visualizer and algorithm tracer.
Your primary goal is to analyze the following ${language} code and represent its execution visually, step-by-step minimal text.

==============================
${code}
==============================

Instructions:
1.  If the code contains any widely used classic named algorithm then first start with "This code uses : 'Algorithm name'".
2.  Show the "Initial State" diagram of all data structures.
3.  Trace the algorithm's execution. For **each loop iteration or significant step**:
    a. Add a "Step X:" title and use horizontal lines (----) to separate it.
    b. Redraw the *entire* visual diagram to show its new state.
    c. Add a highly concise "1-line Explanation:" line describing what just happened.
    d. Add a highly concise, 1-line 'Note:' describing the key action (e.g., 'Note: Swapped 5 and 2', 'Note: Pointer moved'). **Keep this under 10 words.**
4.  Finally, show the "Final State".
5.  End with a brief summary of the "Data Structures" and "Algorithm" being used.
6.  **TEXT WRAPPING:** To prevent horizontal scrolling, you MUST manually add line breaks (newlines) to all your text.
    - NO line of text (explanation, title) should be
      wider than 80 characters.
    - If an explanation is long, wrap it to the next line.
CRITICAL FORMATTING RULES:
1.  **VISUALS (RECURSION):** For 'divide and conquer' algorithms, you MUST
    use atleast 7-8 elements
    draw a tree diagram for the "Divide Phase". Show the original array at
    the root and its subarrays as children, down to the base cases.

    **CORRECT STYLE:**
    Divide Phase:
                          [8, 3, 1, 7, 0, 10, 2]
                     /                             \
            [8, 3, 1, 7]                          [0, 10, 2]
           /            \                        /          \
      [8, 3]          [1, 7]                [0, 10]         [2]
      /    \          /    \                  /     \
    [8]    [3]      [1]    [7]              [0]     [10]

2.  **VISUALS (MERGE STEP):** Each merge step MUST be a dedicated diagram that
    clearly isolates the two subarrays being merged and the temporary array.
    Use arrows ('->') to show elements moving.

    **CORRECT STYLE:**
    Subarray 1: │ 1 │ 3 │   (left ptr: ▲)
    Subarray 2: │ 2 │ 4 │   (right ptr: ▲)
    
    Action: Comparing 1 and 2. 1 is smaller.
    Move: 1 -> Temp
    
    Temp Array: │ 1 │   │   │   │
3.  **CRITICAL VISUALS RULE:** To ensure correct pointer alignment, all
    arrays, strings, or patterns MUST be drawn with each element in
    its own box.
    
    **Unreliable (Do NOT use this):**
    pattern: A B A B C
             ▲   ▲
             pre suf

    **CORRECT (You MUST use this style):**
    pattern: │ A │ B │ A │ B │ C │
             └─┬─┘─┬─┘─┬─┘─┬─┘─┬─┘
               ▲   ▲
               pre suf

4.  **POINTER LABELS:** Pointer labels (like 'pre', 'suf', 'i', 'j')
    must be centered directly below their corresponding '▲' pointer.
5. **CRITICAL VISUALS (TREES):** To indicate the "current node"
    (i.e., the node being visited by the current function call),
    you MUST enclose that node's value in brackets: [ ].

    **Correct (Node 2 is current):**
    Tree:
          1
         / \
       [2]  3
       / \
      4   5

    **Incorrect (ambiguous arrow):**
    Tree:
          1
         / \
        2   3  <-- current
    **Incorrect (incorrect placement of branch):**
    Tree:
          4
        / \
      [2]    6
      / \  / \
   (1)  3  5  7
    
    **Correct (correct placement of branch):**
    Tree:
          4
         / \
      [2]   6
      / \  / \
   (1)   3 5  7
    ** Also for tree related question if required take more nodes to enhance understanding.
6. **CRITICAL VISUALS (LINKED LISTS):** You MUST use the detailed box style for nodes and ensure perfect alignment of pointers and boxes.
      INCORRECT ALLIGNMENT IN BOX:
      List: ... ───►│ 3 │ • │  
             └─┬─┴───┘ 
      CORRECT:
      List: ┌───┬───┐    ┌───┬───┐
            │ 1 │ • ├───►│ 2 │ • ├───► NULL
            └─┬─┴───┘    └─┬─┴───┘
              ▲
             head
      INCORRECT BOX AS IT MISSED THE DOWN SIDE OF THE BOXES:
      List:
      NULL◄───┌───┬───┐    ┌───┬───┐    ┌───┬───┐    ┌───┬───┐
              │ 1 │ • │    │ 2 │ • ├───►│ 3 │ • ├───►│ 4 │ • ├───►...
              └─┬─┴───┘    └─┬─┴───┘ 
                ▲            ▲
               prev         curr
                           nxt
      INCORRECT AS IT MISSED THE UPPER SIDE OF THE BOXES:
      List:
                     ┌───┬───┐    ┌───┬───┐    
      NULL◄───...◄───│ 1 │ • │◄───│ 2 │ • │◄───│ 3 │ • │    │ 4 │ • ├───►...
                     └─┬─┴───┘    └─┬─┴───┘    └─┬─┴───┘    └─┬─┴───┘
                                                ▲            ▲
                                               prev         curr
                                                             nxt
      CORRECT:
      List:
      NULL◄───┌───┬───┐    ┌───┬───┐    ┌───┬───┐    ┌───┬───┐
              │ 1 │ • │    │ 2 │ • ├───►│ 3 │ • ├───►│ 4 │ • ├───►...
              └─┬─┴───┘    └─┬─┴───┘    └─┬─┴───┘    └─┬─┴───┘
                ▲            ▲
               prev         curr
                            nxt                                                      
7.  **TEXT WRAPPING:** To prevent horizontal scrolling, you MUST manually
    add line breaks (newlines) to all your text.
    - NO line of text (explanation, title, or diagram) should be
      wider than 80 characters.
    - If an explanation is long, wrap it to the next line.

8.  **SINGLE CODE BLOCK:** You MUST wrap the entire visual trace (all
    summaries, steps, diagrams, and explanations) in a SINGLE
    Markdown text code block (starting with \`\`\`text and ending
    with \`\`\`).
`;

    const result = await model.generateContent(prompt);

    // ✅ Safely extract text output
    const text = result.response?.text?.() || "No response generated by the AI.";
    res.json({ analysis: text });
  } catch (err) {
    console.error("❌ Error in /api/visualize:", err);
    res.status(500).json({ error: "Internal Server Error", details: err.message });
  }
});

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`✅ Backend running on port ${PORT}`));
